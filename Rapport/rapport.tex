\documentclass[a4paper, 12pt]{article}

\usepackage[left = 1.5cm,
            right = 1.5cm,
            top = 1.5cm,
            bottom = 1.5cm,
            footskip = 0cm]{geometry}
\usepackage{graphicx} % Required for inserting images
\usepackage{wrapfig}
\usepackage{listings}
\usepackage{xcolor}

\definecolor{codebackground}{rgb}{0.95,0.95,0.92} % Choisir une couleur de fond de code ici

\lstdefinestyle{mystyle}{
    basicstyle=\ttfamily,
    frame=single,
    rulecolor=\color{black},
    backgroundcolor=\color{codebackground},
}

\lstset{style=mystyle}

\title{\textbf{Rapport pour le projet de INFOF202}}
\author{
    Ransy Lenny
    \and
    Lejeune Lucas
    }
\date{Janvier 2024}
\renewcommand*\contentsname{Table des matières}

\begin{document}
\setlength{\parindent}{0em}

\maketitle

Ce rapport vise a documenter le projet "Frogger" que nous avons réaliser. Nous traiterons les tâches que nous avons réalisées et comment nous les avons réalisées. Pour cela, nous parlerons des classes que nous avons codées pour faire ce projet, comment elles sont réparties dans le code et comment elles intéragissent entre elles. Nous justifierons aussi comment nous avons utilisé le modèle de conception MVC dans la partie jeu.

\tableofcontents

\pagebreak

\section{Résumé des tâches réalisées et fonctionnement du jeu}
% Résumer comment le jeu marche et listes les tâches réalisées
Nous avons réalisé les tâches principales et toutes les tâches additionnelles, sauf la tâches de l'éditeur de niveau. 
Ouvrons le jeu et voyons ce qui se passe. 
% Parler du fonctionnement du jeu quand tout sera fini

\section{Structure des fichiers: Utilisation du MVC}
% Parler de l'orga des fichiers

La structure des fichiers peut se diviser en plusieurs parties: les fichiers du jeu, ceux des menus, les mains et les images du jeu. \\

\begin{wrapfigure}{r}{3cm}
\includegraphics[width=3cm]{Images/folders.jpg}
\end{wrapfigure}

Le dossier \texttt{ContentManagers} contient tout les fichiers de code en rapport avec la gestion des menus du jeu.\\

Les dossiers \texttt{Controller}, \texttt{Model} et \texttt{View} contiennent le code parmettant de faire tourner le jeu (la partie plateau, qui ne compte pas le menu).
Cette disposition met en évidence l'utilisation du MVC. Prenons la gestion de la grenouille comme exemple. 
Les fichiers gérant les contrôles de celle-ci se trouvent dans le dossier \texttt{Controller}, ceux qui gèrent ses propriétés dans le plateau se trouvent dans \texttt{Model} et enfin, ceux qui gèrent son affichage se trouvent dans \texttt{View}. Tout le code de ces fichiers est utilisé dans les fichiers de \texttt{GameManagers} pour avoir un jeu fonctionnel.\\

Le dossier \texttt{levels} contient les données des niveaux sauvegardés en fichiers \texttt{.csv}, et les scores obtenus sur ceux-ci. Plus de détails seront donnés dans les chapitres concernés. \\

Le dossier \texttt{tooling} contient tout les outils construits grâce aux outils venant la librairie FLTK qui sont surtout utilisés dans la partie \texttt{View} et \texttt{ContentManagers}. \\

Le fichiers \texttt{constants.hpp} contient toutes les constantes utilisées dans le projet, comme par exemple la taille des bouttons dans le menu. \\

Enfin, les fichiers \texttt{main.cpp} et \texttt{mainwindow.hpp} s'occupent d'assembler toutes les classes et fonctions ensemble, pour obtenir l'application Frogger au complet. 

\section{Réalisation de la base du jeu (Tâches de base)}
% On parle du tout début juste avec les roadlanes
Bien sûr, pour cette tâche, la première chose à faite a été de faire un support pour utiliser fltk. C'est là que les fichiers \texttt{main.cpp} et \texttt{MainWindow.hpp} rentrent en jeu.

\subsection{Modèle}

Il nous faut maintenant un modèle fonctionnel. Le but est de d'abord faire un plateau de jeu. \\

Les rangées sont des objets de classe \texttt{Lane}, classe qui est définie dans le fichier \texttt{lanes.hpp}. La classe \texttt{BoardModel} contient alors un vecteur de pointeurs vers des objets \texttt{Lane}. Pour avoir différents types de rangées, il suffit alors de définir ces types grâce à de l'héritage sur la classe \texttt{Lane}. Nous définissons alors dans le fichier \texttt{lane.hpp} les classes \texttt{FinnishLane} (nous en parlons dans le chapitre \ref{lilies}), \texttt{SafeLane} et \texttt{RoadLane}. \\

La classe \texttt{SafeLane} représente une rangée basique sans aucun obstacle. La classe \texttt{RoadLane} est par contre un peu plus complexe. Nous voulons d'abord définir ce qu'est une voiture, ceci se passe dans le fichier \texttt{movingobjects.hpp}. Une voiture est un objet de classe \texttt{Car} qui contient quelques getters et une méthode \texttt{collide} qui servira à voir s'il y a une collision avec la grenouille. Cette classe hérite de la classe abstraite \texttt{MovingObject}. Cela nous permet de créer une classe abstraite appelée \texttt{MovingObjectLane} qui hérite de \texttt{Lane} et qui possède en instance un vecteur de pointeurs vers des objets de classe \texttt{MovingObject}. Cette classe possède une méthode qui permet de regarder s'il y a collision entre la grenouille et au moins un objet. La classe \texttt{RoadLane} est alors juste un successeur de la classe \texttt{MovingObjectLane}. \\

Toutes les classes et méthodes sont après assemblées dans la classe \texttt{BaordModel} pour faire un plateau fonctionnel.

Parlons maintenant de la grenouille. Elle sera définie par un objet de classe \texttt{Frog}, classe qui est définie dans le fichier \texttt{frog.hpp}. Les collisions entre celle-ci et les objets sont gérées par les objets qui possèdent des méthodes qui prennent un référence vers la grenouille en paramêtre. La classe \texttt{Frog} possède alors un getter vers la rangée à laquelle elle se trouve, et un autre vers sa position x (en pixels). Cette classe possède tout de même une méthode \texttt{inBaord} qui vérifie si la grenouille ne sort pas du plateau. C'est aussi dans cette classe que sont gérés la mort, mais nous parlerons de cela dans le chapitre \ref{lives}. L'utilité des autres méthodes de cette classe sera abordée plus tard.

\subsection{Controlleur}

Les contrôles de la grenouille se passent dans la classe \texttt{Controller} qui se trouve quand le fichier \texttt{controller.hpp} qui est contenu dans le dossier \texttt{Controller}.
La classe \texttt{Frog} possède déjà des méthodes permettant de changer sa position sur le plateau, il faut alors juste les utiliser quand nous appuyons sur une touche. La méthode \texttt{processKey} sert à gérer ces actions. Les contrôles se font avec les touches zqsd comme pour beaucoup de jeux. 

\subsection{Vue}

Tout ce dont nous allons parler dans ce sous-chapitre se passe dans le dossier \texttt{View}. Pour résumer, pour presque chaque classe de la partie modèle, il y a une classe de la partie vue qui s'occupe de l'affichage de ce modèle. \\

D'abord, nous avons un fichier \texttt{movingobjectview.hpp} qui contient la classe \texttt{CarView} qui hérite de la classe \texttt{MovingObjectView}. L'intérêt de ces classes est de pouvoir utiliser la méthode \texttt{draw} pour afficher l'objet sur la plateau. Les couleurs sont choisies dans le constructeur et les tailles sont données par l'objet de classe \texttt{MovingObject} qu'elle prennent en paramêtre dans le constructeur. \\

Ensuite, nous avons un fichier \texttt{laneview.hpp} qui possède la classe abstraite \texttt{LaneView} et les classes héritantes \texttt{SafeLaneView}, \texttt{FinishLaneView} et \texttt{RoadLaneView}. Leur intérêt est aussi de pouvoir utiliser la méthode draw pour les afficher sur le plateau. La classe \texttt{RoadLaneView} possède en plus un vecteur de pointeurs vers des objets de type \texttt{CarView} pour pouvoir dessiner les voitures sur les rangées concernées. La méthode \texttt{draw} de \texttt{CarView} est alors appelée dans la méthode \texttt{draw} de \texttt{RoadLaneView}. \\

Nous parlerons de l'affichage de la grenouille dans le chapitre \ref{frogview}

Enfin, à l'aide de toutes ces méthodes \texttt{draw} (il y en a aussi une pour la grenouille, nous pouvons créer une classe \texttt{BoardView} dans le fichier \texttt{boardview.hpp} contenant une méthode \texttt{draw} elle même et qui va dessiner le plateau selon l'instance de classe \texttt{BoardModel} (sous forme de pointeur) qui lui sera donnée.

\subsection{Assemblage pour faire un jeu fonctionnel}

Il nous faut maintenant assembler le tout pour faire un plateau fonctionnel. Ceci se fait dans le dossier \texttt{GameManagers}, et plus particulièrement dans le fichier \texttt{gameloop.hpp}. Dans celui-ci se trouve la classe \texttt{GameLoop} prennant tout ce que nous avons défini (et d'autres éléments dont nous parlerons plus tard) en instance. Le plateau s'initialise alors avec le constructeur, et s'anime en exécutant à chaque frame la méthode \texttt{update}. Nous verrons plus tard où cette méthode est exécutée. \\

\begin{footnotesize} \begin{lstlisting}[language=C++]
class GameLoop {
    private:
        std::shared_ptr<BoardModel> bm;
        std::shared_ptr<BoardView> bv;
        std::shared_ptr<FrogView> fv;
        std::shared_ptr<Frog> frog;
        std::shared_ptr<Score> score;
        std::shared_ptr<ScoreView> sv;
        std::shared_ptr<Controller> c;
        std::unique_ptr<ScoreSaver> ssv;
        std::shared_ptr<Score> best_score;
        std::unique_ptr<ScoreView> bs_show;
    public:
        GameLoop(unsigned int lvl);
        void update();
        std::shared_ptr<BoardModel> getModel();
        std::shared_ptr<BoardView> getView();
        std::shared_ptr<FrogView> getFrog();
        ~GameLoop() {}
};
\end{lstlisting} \end{footnotesize}

\section{Réalisation des tâches additionnelles}
Maintenant que les tâches principales sont réalisées et que nous avons une bonne base, nous pouvons implémenter les fonctionnalités supplémentaires. 

\subsection{Rangées d'eau, buches et tortues}

\subsection{Nénuphars} \label{lilies}

\subsection{Vies de la grenouille} \label{lives}

\subsection{Tortues plongeantes}

\subsection{Directions de la grenouille} \label{frogview}

\subsection{Score}

\subsection{Meilleur score}

\subsection{Gestion des menus et écran d'accueil}

\subsection{Niveaux et sélection de niveau}

\subsection{Vies}


\end{document}