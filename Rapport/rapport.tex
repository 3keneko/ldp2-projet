\documentclass[a4paper, 12pt]{article}

\usepackage[left = 1cm,
            right = 1cm,
            top = 1cm,
            bottom = 1cm,
            footskip = 0cm]{geometry}
\usepackage{graphicx} % Required for inserting images
\usepackage{wrapfig}
\usepackage{listings}
\usepackage{xcolor}

\linespread{0.9}
\setlength{\parskip}{0pt}

\definecolor{codebackground}{rgb}{0.95,0.95,0.92} % Couleur de fond du code
\definecolor{codepurple}{rgb}{0.58, 0, 0.82}
\definecolor{codegreen}{rgb}{0, 0.6, 0}

\lstdefinestyle{mystyle}{
    language=C++,
    basicstyle=\scriptsize\ttfamily,
    frame=single,
    rulecolor=\color{black},
    backgroundcolor=\color{codebackground},
    commentstyle=\color{codegreen},
    keywordstyle=\color{blue},
    numberstyle=\tiny\color{codepurple},
    stringstyle=\color{red},
    lineskip={-1.5pt}
}

\lstset{style=mystyle}

\title{\textbf{Rapport pour le projet de INFOF202}}
\author{
    Ransy Lenny
    \and
    Lejeune Lucas
    }
\date{Janvier 2024}
\renewcommand*\contentsname{Table des matières}

\begin{document}
\setlength{\parindent}{0em}

\maketitle

Ce rapport vise a documenter le projet "Frogger" que nous avons réaliser. 
Nous traiterons les tâches que nous avons réalisées et comment nous les avons réalisées. 
Pour cela, nous parlerons des classes que nous avons codées pour faire ce projet, 
comment elles sont réparties dans le code et comment elles intéragissent entre elles. 
Nous justifierons aussi comment nous avons utilisé le modèle de conception MVC dans 
la partie jeu. \\

Nous avons réalisé les tâches principales et toutes les tâches additionnelles, sauf la tâches de l'éditeur de niveau. 
Ouvrons le jeu et voyons ce qui se passe. 

\section{Structure des fichiers: Utilisation du MVC}
% Parler de l'orga des fichiers
\begin{wrapfigure}{r}{3cm}
    \includegraphics[width=3cm]{Images/folders.png}
\end{wrapfigure}

La structure des fichiers peut se diviser en plusieurs parties: les fichiers du jeu, ceux des menus, les mains et les images du jeu. \\

- Le dossier \texttt{ContentManagers} contient tout les fichiers de code en rapport avec la gestion des menus du jeu.\\
- Les dossiers \texttt{Controller}, \texttt{Model} et \texttt{View} contiennent le code parmettant de faire tourner le jeu (la partie plateau, qui ne compte pas le menu).
Cette disposition met en évidence l'utilisation du MVC. Prenons la gestion de la grenouille comme exemple. 
Les fichiers gérant les contrôles de celle-ci se trouvent dans le dossier \texttt{Controller}, ceux qui gèrent ses propriétés dans le plateau se trouvent dans \texttt{Model} et enfin, ceux qui gèrent son affichage se trouvent dans \texttt{View}. Tout le code de ces fichiers est utilisé dans les fichiers de \texttt{GameManagers} pour avoir un jeu fonctionnel.\\
- Le dossier \texttt{levels} contient les données des niveaux sauvegardés en fichiers \texttt{.csv}, et les scores obtenus sur ceux-ci. Plus de détails seront donnés dans les chapitres concernés. \\
- Le dossier  \texttt{imgs} contient les images utilisées dans le programme//
- Le dossier \texttt{tooling} contient tout les outils construits grâce aux outils venant la librairie FLTK qui sont surtout utilisés dans la partie \texttt{View} et \texttt{ContentManagers}. \\
- Le fichiers \texttt{constants.hpp} contient toutes les constantes utilisées dans le projet, comme par exemple la taille des bouttons dans le menu. \\
- Enfin, les fichiers \texttt{main.cpp} et \texttt{mainwindow.hpp} s'occupent d'assembler toutes les classes et fonctions ensemble, pour obtenir l'application Frogger au complet. 

\section{Réalisation de la base du jeu (Tâches de base)}
% On parle du tout début juste avec les roadlanes
Bien sûr, pour cette tâche, la première chose à faite a été de faire un support pour utiliser fltk. 
C'est là que les fichiers \texttt{main.cpp} et \texttt{MainWindow.hpp} rentrent en jeu. 
Les classes et méthodes utiliseés dans les classes suivantes seront bien-sûr abordées dans la suite. 

\begin{lstlisting}
int main(int argc, char *argv[]) {
    std::srand(static_cast<unsigned>(time(nullptr)));
    auto c = std::make_shared<ContentManager>(nullptr);
    auto ws = std::make_unique<WelcomeScreen>(c);
    c->changeContents(std::move(ws));
    MainWindow window(c);
    window.show(argc, argv);
    return Fl::run();
}
\end{lstlisting}

\begin{lstlisting}
class MainWindow : public Fl_Window {
    private:
        std::shared_ptr<ContentManager> contents;
    public:
        MainWindow(std::shared_ptr<ContentManager> contents);
        void draw() override;
        int handle(int event) override;
        static void Timer_CB(void *userdata);
};
\end{lstlisting}

\subsection{Modèle}

Il nous faut maintenant un modèle fonctionnel. 
Le but est de d'abord faire un plateau de jeu.
Tout ceci se passe dans le dossier \texttt{Model}.

Les rangées sont des objets de classe \texttt{Lane}, 
classe qui est définie dans le fichier \texttt{lanes.hpp}.

\begin{lstlisting}
class Lane {
    private:
        const unsigned int id_num;
    public:
        Lane(const unsigned int id_num);
        unsigned int getId() const;
        virtual void diveUpdate() {}
        virtual ~Lane() {}
};  
\end{lstlisting}

La classe \texttt{BoardModel} contient alors un vecteur de pointeurs 
vers des objets \texttt{Lane}.

\begin{lstlisting}
class BoardModel {
private:
    std::shared_ptr<FinishLane> the_finish_lane;
    std::vector<std::shared_ptr<Lane>> lanes {};
    unsigned time = 0;
public:
    BoardModel(std::vector<std::shared_ptr<Lane>> lanes);
    void updateTurtles(std::shared_ptr<Lane> lane);
    void update(); // moves the objects on the board
    bool gameWon();
    bool isOutOfBoard(Frog& frog);
    bool frogOnLily(Frog& frog);
    void addLane(std::shared_ptr<Lane> lane);
    std::vector<std::shared_ptr<Lane>> getLanes();
    bool anyCollision(Frog& frog);
    void handleCollision(Frog& frog);
    ~BoardModel() {}
    unsigned getTime() const  { return time; }
};
\end{lstlisting}

Pour avoir différents types de rangées, 
il suffit alors de définir ces types grâce à de l'héritage sur la classe \texttt{Lane}. 
Nous définissons alors dans le fichier \texttt{lane.hpp} 
les classes \texttt{FinnishLane} (nous en parlons dans le chapitre \ref{lilies}), 
\texttt{SafeLane} et \texttt{RoadLane}.

\begin{lstlisting}
class SafeLane: public Lane {
    public:
        SafeLane(const unsigned int id);
        ~SafeLane() {}
};
\end{lstlisting}

\begin{lstlisting}
class MovingObjectLane: public Lane {
    protected:
        std::vector<std::shared_ptr<MovingObject>> mv;
        int lane_speed;
    public:
        MovingObjectLane(const unsigned int id, int lane_speed=0);
        bool frogCollide(Frog& frog);
        std::vector<std::shared_ptr<MovingObject>> getMovingObjects();
        virtual void handleAfterCollision(Frog& frog) = 0;
        virtual bool waterLane() const = 0 ;
        virtual ~MovingObjectLane() {}
};
\end{lstlisting}

\begin{lstlisting}
class RoadLane: public MovingObjectLane {
    public:
        RoadLane(const unsigned int id_num
                , const unsigned int& car_by_pack
                , const unsigned int& space_between_cars
                , const unsigned& space_between_packs
                , const int& first_car_placement
                , const unsigned int& size_car
                , const int& speed=1);
        bool waterLane() const override { return 0; }
        void handleAfterCollision(Frog& frog) override;
        std::vector<std::shared_ptr<Car>> getCars() const;
         ~RoadLane() {}
};
\end{lstlisting}

Nous voulons d'abord définir ce qu'est une voiture, 
ceci se passe dans le fichier \texttt{movingobjects.hpp}. 

\begin{lstlisting}
class MovingObject {
    protected:
        const int speed;
        int x;
        const unsigned int size;
        const unsigned int lane_id;
    public:
        MovingObject(const int speed, int x, const unsigned int size, const unsigned lane_id);
        void move();
        unsigned getSize() const;
        unsigned getId() const;
        // returns the x coordinate of the center of the object
        int getCenterX() const;
        std::tuple<int, int> getBoundaries() const;
        int getX() const;
        // returns true if this element collides with the frog
        virtual bool collide(Frog& frog) = 0;
        int getSpeed() const;
      
        // Methods regarding diving turtles
        virtual void dive() {}
        virtual void undive() {}
        virtual bool isDiving() const;
        virtual ~MovingObject() {}
};
\end{lstlisting}

\begin{lstlisting}
class Car: public MovingObject {
public:
    Car(int speed, unsigned int head, const unsigned int size, const unsigned lane_id);
    bool collide(Frog& frog) final override;
    ~Car() {}
};
\end{lstlisting}

Toutes les classes et méthodes sont après assemblées dans la classe \texttt{BaordModel} 
pour faire un plateau fonctionnel.

Parlons maintenant de la grenouille. 
Elle sera définie par un objet de classe \texttt{Frog}, 
classe qui est définie dans le fichier \texttt{frog.hpp}.

\begin{lstlisting}
class Frog {
    private:
        // Frog Position and Direction (important for display)
        unsigned int lane_number;
        int x;
        FrogDirection direction = FrogDirection::North;
        int lives;
        std::shared_ptr<Score> score;
    public:
        Frog(unsigned int lane_number, int x, std::shared_ptr<Score> score);

        // Standard getters
        unsigned int getLane() const ;
        int getX() const;
        int getLives() const;
        FrogDirection getDirection() const;

        // Methods in charge of moving the frog (interacting with the controller)
        void goUp();
        void goDown();
        void goLeft();
        void goRight();

        // Moves the frog in a given direction (helpful when frog is sitting on logs)
        void go(int speed);
        // Returns false only if the frog is outside
        bool inBoard();

        // Methods in charge of life and death of the frog
        void resetPos();
        bool alive();
        void kill();
        void inWaterLilies();

        ~Frog(){}
};
\end{lstlisting}

\subsection{Controlleur}

Les contrôles de la grenouille se passent dans la classe \texttt{Controller} 
qui se trouve quand le fichier \texttt{controller.hpp} qui est contenu dans 
le dossier \texttt{Controller}.
La classe \texttt{Frog} possède déjà des méthodes permettant de changer sa position 
sur le plateau, il faut alors juste les utiliser quand nous appuyons sur une touche. 
La méthode \texttt{processKey} sert à gérer ces actions. 
Les contrôles se font avec les touches zqsd comme pour beaucoup de jeux. 

\begin{lstlisting}
class Controller {
    private:
        std::shared_ptr<Frog> f;
        std::map<char, bool> is_pressed;
        unsigned int count = 0;
    public:
        Controller(std::shared_ptr<Frog> f);
        void decrement();
        void processKey(char& c);
        void updatePressedKeys(const char&& c);
        void resetPressedKeys();
        ~Controller() {}
};
\end{lstlisting}

\subsection{Vue}

Tout ce dont nous allons parler dans ce sous-chapitre se passe dans le dossier \texttt{View}. 
Pour résumer, pour presque chaque classe de la partie modèle, 
il y a une classe de la partie vue qui s'occupe de l'affichage des objets de cette classe.
L'intérêt de ces classes est de pouvoir utiliser la méthode \texttt{draw} pour afficher 
l'objet sur la plateau. 

\underline{Dans movingobjectview.hpp:} \hspace{0.5cm}

\begin{lstlisting}
class MovingObjectView {
    protected:
        std::shared_ptr<MovingObject> mv;
        std::unique_ptr<RectangleDrawer> object_drawer;
    public:
        MovingObjectView(std::shared_ptr<MovingObject> mv);
        virtual void draw();
        std::shared_ptr<MovingObject> getMovin();
        virtual ~MovingObjectView() {}
};
\end{lstlisting}

\begin{lstlisting}
class CarView: public MovingObjectView {
    public:
        CarView(std::shared_ptr<Car> c);
        ~CarView() {}
};
\end{lstlisting}

\underline{Dans laneview.hpp:} \hspace{0.5cm}

\begin{lstlisting}
// An abstract class that helps model a lane
class Lane {
    private:
        const unsigned int id_num;
    public:
        Lane(const unsigned int id_num);
        unsigned int getId() const;
        virtual void diveUpdate() {}
        virtual ~Lane() {}
};
\end{lstlisting}

\begin{lstlisting}
class FinishLane: public Lane {
    private:
        std::vector<std::shared_ptr<WaterLilies>> lilies;
    public:
        FinishLane(const unsigned int id);
        std::vector<std::shared_ptr<WaterLilies>> getLilies();
        ~FinishLane() {}
};
\end{lstlisting}

\begin{lstlisting}
class SafeLane: public Lane {
    public:
        SafeLane(const unsigned int id);
        ~SafeLane() {}
};
\end{lstlisting}

\begin{lstlisting}
class MovingObjectLane: public Lane {
    protected:
        std::vector<std::shared_ptr<MovingObject>> mv;
        int lane_speed;
    public:
        MovingObjectLane(const unsigned int id, int lane_speed=0);
        bool frogCollide(Frog& frog);
        std::vector<std::shared_ptr<MovingObject>> getMovingObjects();
        virtual void handleAfterCollision(Frog& frog) = 0;
        virtual bool waterLane() const = 0 ;
        virtual ~MovingObjectLane() {}
};   
\end{lstlisting}

\begin{lstlisting}
class RoadLane: public MovingObjectLane {
    public:
        RoadLane(const unsigned int id_num
                , const unsigned int& car_by_pack
                , const unsigned int& space_between_cars
                , const unsigned& space_between_packs
                , const int& first_car_placement
                , const unsigned int& size_car
                , const int& speed=1);
        bool waterLane() const override { return 0; }
        void handleAfterCollision(Frog& frog) override;
        std::vector<std::shared_ptr<Car>> getCars() const;
        ~RoadLane() {}
};
\end{lstlisting}

Nous parlerons de l'affichage de la grenouille dans les chapitres \ref{lives} et \ref{frogview}.

\underline{Dans boardview.hpp:} \hspace{0.5cm}

\begin{lstlisting}
class BoardView {
    private:
        std::vector<std::shared_ptr<LaneView>> lanes;
        std::shared_ptr<BoardModel> b;
    public:
        BoardView(std::vector<std::shared_ptr<LaneView>> lanes,
                    std::shared_ptr<BoardModel> b);
        void draw();
        std::vector<std::shared_ptr<LaneView>> getLaneList();
        ~BoardView() {}
};
\end{lstlisting}

Les outils utilisés pour afficher les éléments du jeu avec FLTK se trouvent tous 
dans le dossier \texttt{tooling}. 
Comme ceux-ci ne soont que des outils et n'ont pas d'impact sur le fonctionnement 
du jeu en lui même, 
nous n'en parlerons pas dans ce rapport.

\subsection{Assemblage pour faire un jeu fonctionnel}

Il nous faut maintenant assembler le tout pour faire un plateau fonctionnel. 
Ceci se fait dans le dossier \texttt{GameManagers}, et plus particulièrement 
dans le fichier \texttt{gameloop.hpp}. 

\begin{lstlisting}
class GameLoop {
    private:
        std::shared_ptr<BoardModel> bm;
        std::shared_ptr<BoardView> bv;
        std::shared_ptr<FrogView> fv;
        std::shared_ptr<Frog> frog;
        std::shared_ptr<Score> score;
        std::shared_ptr<ScoreView> sv;
        std::shared_ptr<Controller> c;
        std::unique_ptr<ScoreSaver> ssv;
        std::shared_ptr<Score> best_score;
        std::unique_ptr<ScoreView> bs_show;
    public:
        GameLoop(unsigned int lvl);
        void update();
        std::shared_ptr<BoardModel> getModel();
        std::shared_ptr<BoardView> getView();
        std::shared_ptr<FrogView> getFrog();
        ~GameLoop() {}
};
\end{lstlisting}

\section{Réalisation des tâches additionnelles}
Maintenant que les tâches principales sont réalisées et que nous avons une bonne base, nous pouvons implémenter les fonctionnalités supplémentaires. 

\subsection{Rangées d'eau, buches et tortues} \label{turtle_class}

\underline{\textbf{Modèle:}} 
Dans le fichier \texttt{movingobjects.hpp}, nous implémentons les tortues et les buches. 

\begin{lstlisting}
class Turtle: public MovingObject {
    private:
        bool diving;
    public:
        Turtle(int speed, const unsigned int head, const unsigned int size
                , const unsigned lane_id);
        void dive() final override;
        void undive() final override;
        bool isDiving() const final override;
        bool collide(Frog& frog) final override;
        ~Turtle() {}
};
\end{lstlisting}

\begin{lstlisting}
class Log: public MovingObject {
    public:
        Log(int speed, unsigned int head, const unsigned int size,
            const unsigned lane_id);
        bool collide(Frog& frog) final override;
        ~Log() {}
};
\end{lstlisting} \hspace{0.5cm}

Dans le fichier \texttt{lane.hpp}, nous implémentons deux nouvelles classes héritantes de \texttt{MovingObjectLane}.

\begin{lstlisting}
class LogLane: public MovingObjectLane {
    public:
        LogLane(const unsigned int id_num, const unsigned int& log_by_pack,
                const unsigned int& space_between_logs,
                const unsigned& space_between_packs,
                const int& first_log_placement,
                const unsigned int& size_log, const int& speed=0);
        bool waterLane() const override { return 1; }
        void handleAfterCollision(Frog& frog) override;
        std::vector<std::shared_ptr<Log>> getLogs() const;
        ~LogLane() {}
};
\end{lstlisting}

\begin{lstlisting}
class TurtleLane: public MovingObjectLane {
    unsigned int turtle_by_pack;
    unsigned int diving_pack_id;
    bool is_diving = true;
    unsigned int diving_time;   // In frames
    unsigned int undiving_time;
    unsigned int diving_count = 0;
    public:
        TurtleLane(const unsigned int id_num
                   , const unsigned int& turtle_by_pack
                   , const unsigned int& space_between_turtles
                   , const unsigned& space_between_packs
                   , const int& first_turtle_placement
                   , const unsigned int& size_turtle
                   , const int& speed=1
                   , const unsigned int diving_pack_id = 0
                   , const unsigned int diving_time = 180
                   , const unsigned int undiving_time = 180);
        std::vector<std::shared_ptr<Turtle>> getTurtles() const;
        void handleAfterCollision(Frog& frog) override;
        bool waterLane() const override { return 1; }
        void packDive();
        void packUndive();
        void diveUpdate() final override;
        ~TurtleLane() {}
};
\end{lstlisting} \hspace{0.5cm}

\underline{\textbf{Vue:}} \\
Les implémentations gérant la vue de ces deux nouvelles rangées est similaire que pour celle 
des rangées de voitures.
\begin{lstlisting}
class LogView: public MovingObjectView {
    public:
        LogView(std::shared_ptr<Log> l);
        ~LogView() {}
};
\end{lstlisting}

\begin{lstlisting}
class TurtleView: public MovingObjectView {
    public:
        TurtleView(std::shared_ptr<Turtle> t);
        void draw() final override;
        ~TurtleView() {}
};
\end{lstlisting}

\subsection{Nénuphars} \label{lilies}

Dans le fichier \texttt{Model/waterlilies.hpp}, 
nous définissons une nouvelle classe \texttt{WaterLilies} qui va représenter les nénuphars. 

\begin{lstlisting}
class WaterLilies {
    private:
        int x;
        bool visited=false;
    public:
        WaterLilies(int x);
        int getX();
        bool collide(Frog& frog);
        bool hasBeenVisited();
        void visit();
        ~WaterLilies() {}
};
\end{lstlisting} \hspace{0.5cm}

Nous pouvons maintenant montrer l'implémentation de la classe \texttt{FinishLane}.

\begin{lstlisting}
class FinishLane: public Lane {
    private:
        std::vector<std::shared_ptr<WaterLilies>> lilies;
    public:
        FinishLane(const unsigned int id);
        std::vector<std::shared_ptr<WaterLilies>> getLilies();
        ~FinishLane() {}
};
\end{lstlisting} \hspace{0.5cm}

\subsection{Vies de la grenouille} \label{lives}

Les vies de la grenouille sont représentées par l'instance \texttt{lives} de la classe 
\texttt{Frog}. 
A chaque exécution de \texttt{GameLoop::update()}, 
on regarde si la grenouille respecte une des conditions pour perdre une vie. 
Si oui, alors on décrémente \texttt{lives} avec la méthode \texttt{kill()}. 
Si \texttt{lives} est à 0, 
alors on affiche un écran de défaite (avec le fichier \texttt{imgs/lose.jpeg}).

La classe \texttt{FrogView} s'occupe de dessiner tout ce qui est relié à la grenouille. 
Nous parlons ici seulement des vies, le reste sera abordé dans le chapitre \ref{frogview}. 

\begin{lstlisting}
class FrogView {    
        std::shared_ptr<Frog> frog;
        JPEGDrawer current_image{paths::frog_north_jpeg, frog->getX(),
                                static_cast<int>(frog->getLane()), HEIGHT, WIDTH};
    public:
        FrogView(std::shared_ptr<Frog> f);
        void showLives();
        void draw();
};
\end{lstlisting}

\subsection{Tortues plongeantes} \label{diving_turtles}

Dans le modèle, 
une tortue plonge si son instance \texttt{diving} est à \texttt{True} (voir \ref{turtle_class}). 
Ce statut change surtout le comportement des collisions avec les tortues dans le modèle. 
Nous ordonnons à la tortue de plonger avec les méthodes \texttt{dive()} et \texttt{undive()}. 
Ces ordres sont alors données dans la classe \texttt{TurtleLane} (voir \ref{turtle_class}). 
Comme dans le jeu orginal, nous faisons plonger les tortues par paquets. 
La méthode \texttt{dive\textunderscore update()} va alors se charger de faire plonger et 
remonter les tortues en boucle avec les paramêtres choisis. 
Cette méthode est exécutée à chaque frame dans la méthode \texttt{GameLoop::update()}.

Nous changons forcément commment est affichée la tortue quand elle plonge. Pour cela, nous faisons en sorte que la méthode \texttt{TurtleView::draw()} ne marche que quand la tortue est à la surface.

\subsection{Directions de la grenouille} \label{frogview}

Les directions sont définies avec l'enum class suivante: (dans le fichier \texttt{frog.hpp})

\begin{lstlisting}
enum class FrogDirection {
    North, South, East, West
};
\end{lstlisting}

La grenouille est alors affichée selon la direction dans laquelle elle se trouve.

\subsection{Score}

Le score est un objet de classe \texttt{Score}, 
classe qui est définie dans le fichier \texttt{score.hpp}.
\begin{lstlisting}
class Score {
    private:
        unsigned the_score = 0;
        int max_lane = 0;
    public:
        Score() = default;
        Score(unsigned score): the_score(score) {}

        void reachedWaterlily();
        void update(int new_lane_id);
        unsigned getScore() const;
        void resetBestLane();

        friend bool operator<(Score const& s1, Score const& s2);
        friend bool operator>(Score const& s1, Score const& s2);
        friend bool operator==(Score const& s1, Score const& s2);
        ~Score() = default;
};
\end{lstlisting}

Le score est calculé de la manière suivante: 
Le score commence à 0. 
A chaque fois que la grenouille avance d'une rangée vers le nord, le score monte de 100 points.
Si la grenouille revient en arrière, 
alors elle ne recommencera à gagner des points seulement quand elle aura réatteint la rangée 
la plus haute qu'elle avait avant atteint.
Si la grenouille meurt ou atteint la ligne d'arrivée, le score est conservé et le même système
recommence (c'est à dire que si la grenouille est téléportée à la case départ, et qu'elle
avance d'une rangée vers le nord, alors elle regagne 100 points). \\

L'affichage du score sur le plateau se fait grâce à la classe \texttt{ScoreView}
qui se trouve dans le fichier \texttt{scoreview.hpp}.

\begin{lstlisting}
class ScoreView {
        std::shared_ptr<Score> score;
        Text score_text;
        bool is_best;
    public:
        ScoreView(std::shared_ptr<Score> score, int const& x, int const& y, bool is_best=false);
        std::string stringForScore();
        void draw();
        ~ScoreView() {}
};
\end{lstlisting}

\subsection{Meilleur score}

Le meilleur score et l'interaction avec les fichiers est gérée par la classe ScoreSaver.
Les meilleurs score sont alors stockés dans le fichier \texttt{scores.csv} du dossier
\texttt{levels}.

\begin{lstlisting}
class ScoreSaver {
    private:
        unsigned lvl;
        const std::string file_name { paths::scores };
        std::map<unsigned, unsigned> scores;
    public:
        ScoreSaver(unsigned level);
        void writeToFile();
        void getFromFile();

        Score getHighScore();
        void setNewScore(Score const& score);
        void resetHighScore();
        void setLevel(unsigned& level);
        ~ScoreSaver() {}
};
\end{lstlisting}

Le meilleur score est alors aussi affiché grâce à la classe \texttt{ScoreView} sur le plateau,
mais aussi dans le menu de sélection des niveaux.

\subsection{Gestion des menus et écran d'accueil}

Les classes chargées de la gestion des menus se trouvent dans ContentManagers.

\begin{lstlisting}
class WindowContents;

class ContentManager {
    private:
        std::unique_ptr<WindowContents> contents;
        std::unique_ptr<GameLoop> gl;
    public:
        ContentManager(std::unique_ptr<WindowContents> first_contents):
            contents(std::move(first_contents)), gl(nullptr) {}

        void changeContents(std::unique_ptr<WindowContents> new_contents);

        void manageButtonPush(int x, int y);

        void contentManageAction(actions& action);

        void startGame(std::unique_ptr<GameLoop> g);
        void show();

        static void updateWithAction(std::shared_ptr<ContentManager> cm, actions& action);

        ~ContentManager() { }
};

class WindowContents {
   protected:
        std::weak_ptr<ContentManager> cm; // Observer
    public:
        WindowContents(std::shared_ptr<ContentManager> cm): cm(cm) {}
        WindowContents(std::weak_ptr<ContentManager> cm): cm(cm) {}
        virtual void draw() = 0;
        virtual void manageButtonPush(int x, int y) = 0;
        virtual void manageAction(actions& action) = 0;
        std::weak_ptr<ContentManager> getCM() {
            return cm;
        }

        virtual ~WindowContents() {}
};
\end{lstlisting}
En clair, ces classes fonctionnent de la manière suivante:
Ce qui est affiché dans la fenêtre hérite de WindowContents, 
ainsi, nos menus, et la sélection de niveau héritera de WindowContents, 
ContentManager est la classe se chargeant d'alterner les différents contenus 
que l'on affiche à l'écran,
par exemple, si je décide d'appuyer sur le bouton pour aller au menu de sélection de niveau,
le menu de sélection de niveau et le menu de base sont tous les deux des WindowContents,
et ce qui permet de changer entre les deux est l'instance de ContentManager. \\

Les buttons sont des objets de la classe suivante, 
classe qui se trouve aussi dans le ficher \texttt{content\textunderscore manager.hpp}
\begin{lstlisting}
class ActionButton: public RectangleWithText, public Clickable {
    private:
        actions action;
        WindowContents* wc;
    public:
        ActionButton(int x, int y, int size_w, int size, std::string s, actions action
                     , WindowContents* wc
                     , int fontsize = 20, Color color = Color::MENURECTANGLE
                     , Color text_color = Color::TEXT);
        void draw() override;
        void manageClick(int xMouse, int yMouse);
        bool contains(int xMouse, int yMouse) override;
        ~ActionButton() {}
};
\end{lstlisting}

L'écran d'accueil est représenté par la classe suivante,
qui se trouve dans le ficher \texttt{welcome\textunderscore screen.hpp}.
\begin{lstlisting}
class WelcomeScreen: public WindowContents {
    private:
        ActionButton start_game_button;
        ActionButton go_to_levels;
        Text welcome;
    public:
        WelcomeScreen(std::shared_ptr<ContentManager> cm): WindowContents(cm) {}
        void manageButtonPush(int x, int y) override;
        void manageAction(actions& action) override;
        void draw() override;
        ~WelcomeScreen() {}

};
\end{lstlisting}

\subsection{Niveaux et sélection de niveau}

De la même manière que pour l'écran d'accueil, 
nous faisons un menu s'occupant de la sélection des niveaux.
\begin{lstlisting}
class LevelSelect: public WindowContents {
    public:
        LevelSelect(std::shared_ptr<ContentManager> cm): WindowContents(cm) {
            ss.getFromFile();
            best_score_show.setString("Highest Score: " + std::to_string(ss.getHighScore().getScore()));
        }
        LevelSelect(std::weak_ptr<ContentManager> cm): WindowContents(cm) {
            ss.getFromFile();
            best_score_show.setString("Highest Score: " + std::to_string(ss.getHighScore().getScore()));
        }
        void draw() override;
        void manageButtonPush(int x, int y) override;
        unsigned getLevel();
        void manageAction(actions& action) override;
        ~LevelSelect() {}
};
\end{lstlisting}

\section{Logique du jeu}

\underline{\textbf{Lancement du jeu:}}  \vspace{0.2cm}\\
Lorsque nous lancons le jeu, un objet de classe \texttt{MainWindow} se créé 
et est affiché. 
Celui-ci contient un objet de classe \texttt{ContentManager} qui affiche en premier le
menu principal, c'est à dire un objet de classe \texttt{WelcomeScreen}. \\

\underline{\textbf{Intéractions avec le menu, lancement du premier niveau:}} \vspace{0.2cm} \\
Nous avons deux buttons sur ce menu: "START GAME" et "GO TO LEVELS". 
Appuyer sur "START GAME" nous envoie sur le premier niveau du jeu.
Appuyer sur "GO TO LEVELS" nous envoie sur le sélectionneur de niveau.
Nous pouvons par exemple sélectionner le niveau 1 en ajustant si besoin le 
niveau sélectionné et en appuyant sur "START GAME". \\
Ce menu de sélection de niveau est en fait affiché graĉe à la classe 
\texttt{LevelSeclect}.
La transition se fait dans la classe \texttt{ContentManager}, 
tout en restant dans MainWindow.
Après, grâce au bouton "START GAME",
La classe \texttt{ContentManager} fait marcher un objet de classe \texttt{GameLoop}
qui se change de faire fonctionner le niveau donc les données ont été prises du
fichier \texttt{level1.csv}. \\

\underline{\textbf{Essayons d'avancer d'un rangée vers le nord:}} \vspace{0.2cm} \\
Maintenant que nous sommes dans le premier niveau, la classe \texttt{GameLoop} va 
regarder à chaque instant si nous appuyons sur une touche, et en même temps va
faire marcher les autres classes pour que le plateau soit animé, et 
pour vérifier si la grenouille meurt ou atteint un nénuphar. \\
Appuyons sur la touche "z". Cette information est envoyée au contrôleur.
Celui-ci va alors changer la position et la direction de la grenouille dans le modèle.
Le score sera aussi incrémenté de 100. \\
Toute l'information nécéssaire à l'affichage du plateau est alors envoyée aux classes
gérant la vue, qui vont alors afficher tout les éléments du plateau. La grenouille aura
alors avancé d'une rangée vers l'avant. 

\end{document}
